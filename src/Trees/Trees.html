<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Ryan Cox" />
  <title>Proof Trees in Haskell</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Proof Trees in Haskell</h1>
<p class="author">Ryan Cox</p>
</header>
<p>Letâ€™s begin with an informal description of an algorithm for building a proof tree for general predicate logic with identity (GPLI).</p>
<ol type="1">
<li></li>
</ol>
<p>We begin by setting up the root node of the tree. The root node will consist of a non-empty list of propositions. For example:</p>
<pre><code> (Fa-&gt;Gb)
@x(Fx-&gt;Gx)
   #xGa</code></pre>
<p>Technically, this is just a list, and we could represent it like this:</p>
<pre><code> [(Fa-&gt;Gb), @x(Fx-&gt;Gx), #xGa]</code></pre>
<p>Indeed, it is not just a list, but it is a non-branching node of a tree.</p>
<ol start="2" type="1">
<li></li>
</ol>
<p>Okay, so the next thing we want to do is check to see whether there are any contradictions on the single path of our newly created tree. This will just be an application of a more general function for testing for contradictions applied in the special case of a leaf node.</p>
<ol start="3" type="1">
<li></li>
</ol>
<p>The next thing we want to do is determine which rule we should apply next, if, indeed, we are apply to apply any rule at all. It is generally a good idea to apply PL non-branching rules first, followed by PL branching rules, then existential, then universal, then SI, if we have a choice. We may sometimes have a choice of PL non-branching rules, or, indeed, a choice of any rule. As humans, constructing the tree on paper, we can directly target the relevant proposition to apply the rule to, applying the rule to the open paths the proposition sits on. To keep things simple, we will just apply a particular rule to the first unchecked proposition of the relevant kind that we find as we move down the tree.</p>
<p>We have to make a decision about the data structure for trees. We might naturally take the trees to be binary trees thus.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="dt">Data</span> <span class="dt">Tree</span> a <span class="ot">=</span> <span class="dt">Branch</span> a (<span class="dt">Tree</span> a, <span class="dt">Tree</span> a) <span class="op">|</span> <span class="dt">Leaf</span> <span class="dt">Bool</span> a</span></code></pre></div>
<p>Why the extra argument for leafs? Well, we want to know whether a path on a tree is closed or not. We could use False to indicate a closed path and Tree to indicate an open path.</p>
</body>
</html>
