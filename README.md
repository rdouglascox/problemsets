# problemsets 0.1.0.0

## what **problemsets** does

**problemsets** is a command line tool for generating logic problem sets for introductory logic courses. It outputs the problem sets as .tex files which can then be compiled to .pdf files using **pdflatex**.

Currently, **problem sets** can produce problem sets for translating English sentences into propositional logic (PL); problem sets for testing for properties of formulas of PL using truth tables; problem sets for testing for properties of formulas of PL, MPL, GPL, and GPLI using proof trees; and for determining the truth value of MPL and GPL propositions in models.

Basic usage is as follows:

    > problemsets-exe

This will produce the relevant .tex files in the current working directory. This will simply produce a random set of problem sets. Problem sets can also be generated in a deterministic fashion using the following:

    > problemsets-exe --id 26051

This will produce the set of problem sets numbered 26051. (Exactly how this is done is detailed below). Problem sets can also be generated individualy using the following:

    > problemsets-exe --ps 1

And problem sets can be generated individually in a deterministic fashion as follows.

    > problemsets-exe --ps 1 --id 26051

This will produce problem set 1, number 26051. When **problemsets** is used to produce in a non-determistic fashion to produce a problem set or set of problem sets, the number of the problem sets is printed in the footer of the problem sets. This allows for the recovery of the answers to a problem set using the deterministic method.

Problem sets can be generated in batches by two means, deterministicaly and non-deterministically. A non-deterministic batch of problem sets can be generated using the following:

    > problemsets-exe --batch 100

This will produce 100 distinct sets of all problemsets. If you want to turn these all into .pdf files at once then the following is your friend:

    > for i in *.tex; do pdflatex $i; done

And if you want to clean up all the files generated by pdflatex:

    > for i in *.tex; do pdflatex $i; done && for i in *.log; do rm $i; done && for i in *.aux; do rm $i; done 

Alternatively, you can specify a .tex file that **problemsets** can read a list of numbers from and produce sets of problemsets in a deterministic fashion from. This may be helpful for generating problem sets from a list of numerical student identifiers.

    > problemsets-exe --fromlist studentnumbers.txt

The list of numbers must be line-separated.

WARNING: most of the 'backend' functions used by **problemsets** are re-implementations of old functions for producing trees, tables, and evaluating propositions in models. I've tried to re-implent these functions in ways that introduce more features and in ways that are generally more efficient. They have NOT been thoroughly tested for correctness, either manually, or against each other and other implementations.

## getting **problemsets**

## how **problemsets** works

### translations

So far **problemsets** only implements problem sets for translation from English into PL. The implementation is kind of hacked together. Translation questions are generated by generating a random PL expression, together with its translation and a glossary in unison. 

In fact, a random PL expression is generated, and then elements of the PL expression are substituted with corresponding English expressions in accordance with a glossary. So (A->B) may become 'If Abbey is running then Ben is jumping' or 'Abbey is running only if Ben is jumping'. 

Names are randomly selected from a list of all names given to children in the United States in a particular year according to census data. Verb phrases are randomly generated from a massive list of intransitive '-ing' verbs. This method makes for some humourous and non-sensical sentences. Better results could be achieved by curating the list of verbs found in src/Translations/Verbs.hs

### trees, tables, and models

Tree and table questions are generated in the following manner. 

First, a random stream of appropriate formulas or lists of formulas is generated meeting certain criteria. So perhaps a random stream of PL propositions or lists of PL propositions with two connectives is generated.

Second, this random stream is filtered according to features like the size of the proof tree which is produce, and for other features like satisfiability, unsatisfiability, and so on according to the problem set being produced.

A consequence of this method, is that sometimes **problemsets** can take a while to find an appropriate question and answer pair. For instance, it can take a while to find a pair of equivalent GPLI propositions with at lest three connectives, which produces a tree with only a certain number of branches, and which tree involves at least one application of the substitution of identical rule.

Settings for each of the questions can be found in src/Settings/ . The current settings for the questions are decent, but could be refined in order to rule out some inappropriate answers and to ensure that it doesn't take too long to find an answer.

Given an appropriate formula or set of formulas for the question, an appropriate tree, table, or model is then generated. In the case of models, a random model, appropriate to the formula or set of formulas is generated and then the truth value of the formula or conjunction of formulas is found. 

The trees generated for PL, MPL, and GPL formulas are generated following sensible rules for the order of rule application. So the formulas are selected to generate trees of an appropriate size given that such rules are followed. GPLI trees typically turn out to be worse than human generated GPLI trees, since the substitution of identicals rule, while always applied as a very last resort, is not applied in a very intelligent fashion.

### randomness

Haskell is a purely functional programming language. This complicates things a little when it comes to randomness. Basically, any function in Haskell must always return the same result for a given input. This means no random number functions which return a different result every time they are run.

This complicates things a little when it comes to generating random stuff. However, it also comes with an advantage. Since the bulk of the work in **problemsets** is done by pure functions, it is possible to replicate in a deterministic way the production of problem sets by providing the same random generator to a function which takes a random generator as its argument again. 

So, when you run **problemsets** only a single random number is generated from ouside of the purely functional code. That number is then used as a seed for a random generator. The function which generates this random generator is a pure function, so it returns the same random generator for the same input. So if **problemsets** is run again, but is this time given the number that was randomly generated directly, it will return exactly the same problem set. 

### concurrency 

Generating random problem sets in the way **problemsets** does can be computation heavy. For this reason, **problemsets** generates problem sets concurrently, utilising as many cores and threads as are available. 

## limitations and future improvements

By design, **problemsets** is highly modular. As a consequence, it will be possible to switch out modules for tree building, table building, model building, and random formula generation with improved versions.

Random formula generation for tautologies, contraries, contradictories, and validity, could be improved by 'seeding' the random generator with logical forms known to produce propositions with these properties. The forms could then be filled in or expanded randomly. This would be a far more efficient way of generating large tautologies, for instance, than a random search.

Random formula generation could also be improved by using an alternative algorithm for determining satisfiability. Small gains in efficiency would be multiplied given the nature of the search. 

Tree generation could be improved by implementing a kind of look-ahead for the application of rules, where rules are applied when they generate the lowest number of open paths upon application. I already impliemented a tree building function which generates all possible trees for a given input and can select the smallest or largest tree from the generated set. Needless to say, such a strategy for finding the smallest tree is not particularly efficient and I have not used it here.

Translations could be improved with better curated lists of verbs. 

